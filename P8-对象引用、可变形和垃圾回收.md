# P8-对象引用、可变形和垃圾回收

## 按引用传递

- 对象--标识、类型、值，通常可以改变的只有值，而变量只是它们的名字（or tag）
  - 不可变对象：值不可更改，tuple可以做+=操作，但结果是创建并返回了一个新标识的对象（id变了）
  - 之所以说call by sharing，是从标识（id，在cpython中为地址）的视角来看，多个对象就像是在给一个标识打不同的tag
    <img src="https://raw.githubusercontent.com/eudemoniac/image/main/img/image-20220414133632313.png" alt="image-20220414133632313" style="zoom:50%;" />
- == 比较值（等价于__eq__)，is 比较标识
- Tuple 中不变的是对象的标识
- 而 str 、 bytes 和 array.array 等单一类型序列是扁平的，它们保存的不是引用，而是在连续的内存中 保存数据本身（字符、字节和数字）。

## copy

- = : 给同一个标识打tag
- copy，[:]：浅复制，复制了外层容器，而内部的元素则复制了标识
- deepcopy：完全全新的东西

## call by sharing

这种方案的结果是，函数可能会修改作为参数传入的可变对象，但是无法修改那些对象的 标识（即不能把一个对象替换成另一个对象）。

不要把可变类型作为默认值

这是因为 self. passengers 变成了 passengers 参数默认值的别名。

因此默认值变成了函数对象的属性。因此，如果默认 值是可变对象，而且修改了它的值，那么后续的函数调用都会受到影响。

```
def __init__(self, passengers=None):

if passengers is None:

self.passengers = [] else:

self.passengers = passengers
```

## Del and gc

del 删除 name，而不是对象

## Weakref

弱引用不会增加对象的引用数量。引用的目标对象称为 所指对象 （referent）。因此我们说， 弱引用不会妨碍所指对象被当作垃圾回收。

弱引用在缓存应用中很有用，因为我们不想仅因为被缓存引用着而始终保存缓存对象。

weakref.ref

weakset

如果一个类需要知道所有实例， 一种好的方案是创建一个 WeakSet 类型的类属性，保存实例的引用。如果使用常规的 set ， 实例永远不会被垃圾回收，因为类中有实例的强引用，而类存在的时间与 Python 进程一样 长，除非显式删除类。

```
基本的 list 和 dict 实 例不能作为所指对象，但是它们的子类可以轻松地解决这个问题：

class MyList(list):

"""list的子类，实例可以作为弱引用的目标"""
但是， int 和 tuple 实例不能作 为弱引用的目标，甚至它们的子类也不行。
```

## invariance

对元组 t 来说， t[:] 不创建副本， 而是返回同一个对象的引用。 此外， tuple(t) 获得的也是同一个元组的引用。

 frozenset.copy() 具有相同的效果：它会欺骗你， 返回同一个对象的引用，而不是创建一个副本，

共享字符串字面量是一种优化措施，称为 驻留 （interning）。 CPython 还会在小的整数上使 用这个优化措施，防止重复创建“热门”数字，如 0、 — 1 和 42。 注意， CPython 不会驻留 所有字符串和整数，驻留的条件是实现细节，而且没有文档说明。

## sum

每个Python对象都有标识、类型和值。只有对象的值会不时变化。

不可变集合不变的是所含对象的标识。

变量保存的是引用，这一点对 Python 编程有很多实际的影响。

- 如果左边的变量绑定的是不可变对象，会创建新对象； 如果是可变对象，会就地修改。
- 使用可变类型作为函数参数的默认值有危险，因为如果就地修改了参数，默认值也就变 了，这会影响以后使用默认值的调用。

可变对象还是导致多线程编程难以处理的主要原因，因为某个线程改动对象后，如果 不正确地同步，那就会损坏数据。但是过度同步又会导致死锁。

在 CPython 中，

open('test.txt', 'wt', encoding='utf-8').write('1, 2, 3')

这行代码是安全的， 因为文件对象的引用数量会在 write 方法返回后归零， Python 在销毁内存中表示文件的对象之前， 会立即关闭文件。 然而， 这行代码在 Jython 或 IronPython 中却不安全，因为它们使用的是宿主运行时（Java VM 和 .NET CLR）中的 垃圾回收程序，那些回收程序更复杂，但是不依靠引用计数，而且销毁对象和关闭文 件的时间可能更长。在任何情况下，包括 CPython， 最好显式关闭文件；而关闭文件 的最可靠方式是使用 with 语句，它能保证文件一定会被关闭，即使打开文件时抛出了 异常也无妨。使用 with ，上述代码片段变成了：